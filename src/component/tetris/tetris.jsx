import React, { Component } from 'react';import '../../assets/css/tetris.css';import { Message } from "element-react";class Tetris extends Component {	constructor ( props ) {		super( props );		this.state = {			block: null,		};		this.size = {			x: 10,			y: 15		};		this.blocks = ( position ) => {			const { x, y, index } = position;			return [				{					color: '#FF7F24',					pointer: [						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x + 1, y ), [ x + 1, y ] ],							[ this.getGridIndex( x, y - 1 ), [ x, y - 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x, y - 1 ), [ x, y - 1 ] ],							[ this.getGridIndex( x + 1, y ), [ x + 1, y ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x + 1, y ), [ x + 1, y ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x, y - 1 ), [ x, y - 1 ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ]						] ),					]				},				{					color: '#1C86EE',					pointer: [						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x + 1, y ), [ x + 1, y ] ],							[ this.getGridIndex( x + 1, y - 1 ), [ x + 1, y - 1 ] ],							[ this.getGridIndex( x, y - 1 ), [ x, y - 1 ] ]						] ),					]				},				{					color: '#4EEE94',					pointer: [						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x, y - 1 ), [ x, y - 1 ] ],							[ this.getGridIndex( x, y - 2 ), [ x, y - 2 ] ],							[ this.getGridIndex( x, y - 3 ), [ x, y - 3 ] ]						] ),						new Map( [							[ this.getGridIndex( x - 1, y - 2 ), [ x - 1, y - 2 ] ],							[ this.getGridIndex( x, y - 2 ), [ x, y - 2 ] ],							[ this.getGridIndex( x + 1, y - 2 ), [ x + 1, y - 2 ] ],							[ this.getGridIndex( x + 2, y - 2 ), [ x + 2, y - 2 ] ]						] ),					]				},				{					color: '#BFBFBF',					pointer: [						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ],							[ this.getGridIndex( x + 1, y + 1 ), [ x + 1, y + 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x, y - 1 ), [ x, y - 1 ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x - 1, y + 1 ), [ x - 1, y + 1 ] ]						] ),					]				},				{					color: '#8B4500',					pointer: [						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x + 1, y ), [ x + 1, y ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ],							[ this.getGridIndex( x - 1, y + 1 ), [ x - 1, y + 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x - 1, y - 1 ), [ x - 1, y - 1 ] ]						] ),					]				},				{					color: '#CAFF70',					pointer: [						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ],							[ this.getGridIndex( x, y - 1 ), [ x, y - 1 ] ],							[ this.getGridIndex( x + 1, y - 1 ), [ x + 1, y - 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x + 1, y ), [ x + 1, y ] ],							[ this.getGridIndex( x + 1, y + 1 ), [ x + 1, y + 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x, y - 1 ), [ x, y - 1 ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ],							[ this.getGridIndex( x - 1, y + 1 ), [ x - 1, y + 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x + 1, y ), [ x + 1, y ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x - 1, y - 1 ), [ x - 1, y - 1 ] ]						] )					]				},				{					color: '#9A32CD',					pointer: [						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ],							[ this.getGridIndex( x, y - 1 ), [ x, y - 1 ] ],							[ this.getGridIndex( x - 1, y - 1 ), [ x - 1, y - 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x + 1, y ), [ x + 1, y ] ],							[ this.getGridIndex( x + 1, y - 1 ), [ x + 1, y - 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x, y - 1 ), [ x, y - 1 ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ],							[ this.getGridIndex( x + 1, y + 1 ), [ x + 1, y + 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x + 1, y ), [ x + 1, y ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x - 1, y + 1 ), [ x - 1, y + 1 ] ]						] )					]				}			][ index ]		};		this.randomRange = [ 4, 1, 2, 2, 2, 4, 4 ];		this.history = [];		this.time = null;		this.cacheBlock = null;		this.promptPosition = null;		this.position = null;		this.initPosition = () => {			let index = Math.floor( Math.random() * 7 );			let direction = Math.floor( Math.random() * this.randomRange[ index ] );			return {				direction,				index			}		};		this.handleKeydown = this.handleKeydown.bind( this );	}	componentWillMount () {		this.initData();		this.run();	}	initData () {		this.history = [];	}	run () {		const { x } = this.size;		this.clearBlock();		document.addEventListener( 'keydown', this.handleKeydown );		if ( this.promptPosition ) {			this.position = Object.assign( this.promptPosition, {				x: Math.floor( x / 2 ),				y: -1,			} )		} else {			this.position = Object.assign( this.initPosition(), {				x: Math.floor( x / 2 ),				y: -1,			} );		}		this.promptPosition = this.initPosition();		this.time = setInterval( () => {			this.controlBlock( 40 );		}, 1000 )	}	process ( direction ) {		const history = this.getHistory();		let block = this.blocks( this.position );		if ( this.position.direction < 0 ) {			this.position.direction = block.pointer.length - 1;		}		if ( this.position.direction >= block.pointer.length ) {			this.position.direction = 0;		}		block.pointer = block.pointer[ this.position.direction ];		switch ( this.check( block.pointer, direction, history ) ) {			case 0:				this.cacheBlock = Object.assign( {}, block );				this.setState( { block } );				break;			case 1:				this.controlBlock( 39 );				break;			case 2:				this.controlBlock( 37 );				break;			case 3:				this.controlBlock( 41 );				break;			case -1:				document.removeEventListener( 'keydown', this.handleKeydown );				clearInterval( this.time );				this.saveHistory( this.cacheBlock );				this.saveHistory( block );				this.message( 'error', '游戏结束' );				break;			case -2:				document.removeEventListener( 'keydown', this.handleKeydown );				clearInterval( this.time );				this.saveHistory( this.cacheBlock );				this.run();				break;		}	}	handleKeydown ( e ) {		if ( e.keyCode > 36 && e.keyCode < 41 ) {			this.controlBlock( e.keyCode );		}	}	controlBlock ( code ) {		switch ( code ) {			case 37:				this.position.x--;				this.process( 'left' );				break;			case 38:				this.position.direction++;				this.process( 'up' );				break;			case 39:				this.position.x++;				this.process( 'right' );				break;			case 40:				this.position.y++;				this.process( 'down' );				break;			case 41:				this.position.direction--;				this.process( 'up' );				break;		}	}	check ( pointer, direction, history ) {		const { x, y } = this.size;		let state = 0;		for ( let dot of pointer.values() ) {			let dotX = dot[ 0 ];			let dotY = dot[ 1 ];			if ( dotY >= y ) {				state = -2;				break;			} else {				let index = y - dotY;				let cross = history.length > 0 && history.length >= index && history[ index - 1 ].has( dotX );				if ( cross && direction === 'down' ) {					for ( let dot of pointer.values() ) {						let dotY = dot[ 1 ];						if ( dotY < 0 ) {							state = -1;							break;						}					}					if ( state !== -1 ) state = -2;					break;				}				if ( direction === 'up' && ( cross || dotX < 0 || dotX >= x ) ) {					state = 3;					break;				} else if ( dotX < 0 || ( cross && direction === 'left' ) ) {					state = 1;					break;				} else if ( dotX >= x || ( cross && direction === 'right' ) ) {					state = 2;					break;				}			}		}		return state;	}	message ( type, message ) {		Message( {			customClass: '',			message: message,			type: type,			duration: 0		} );	}	saveHistory ( block ) {		const { y } = this.size;		let history = this.getHistory();		for ( let dot of block.pointer.values() ) {			let dotX = dot[ 0 ];			let dotY = dot[ 1 ];			let indexY = y - dotY;			let historyLength = history.length;			if ( historyLength < indexY ) {				for ( let i = 0; i < indexY - historyLength; i++ ) {					history.push( new Map() );				}			}			let mapY = history[ indexY - 1 ];			mapY.set( dotX, block.color );		}		this.history.push( history );	}	clearBlock () {		const { x } = this.size;		let history = this.getHistory();		for ( let i = 0; i < history.length; i++ ) {			if ( history[ i ].size === x ) {				history.splice( i, 1 );				i--;			}		}		this.history.push( history );	}	getGridIndex ( x, y ) {		return `${ x }_${ y }`;	}	getHistory () {		return this.history.length === 0 ? [] : this.history[ this.history.length - 1 ]	}	render () {		const { x, y } = this.size;		const { block } = this.state;		const history = this.getHistory();		return (			<div className='tetris'>				<div className='tetris-container'>					<div className='tetris-container-main'>						{							( new Array( y ) ).fill( 0 ).map( ( item, j ) => {								let indexY = y - j;								return (									<div className='row' key={ j }>										{											( new Array( x ) ).fill( 0 ).map( ( item, i ) => {												let index = this.getGridIndex( i, j );												let color = null;												if ( history.length > 0 && history.length >= indexY && history[ indexY - 1 ].has( i ) ) color = history[ indexY - 1 ].get( i );												if ( block && block.pointer.has( index ) ) color = block.color;												return (													<Item														key={ index }														color={ color ? color : null }													/>												)											} )										}									</div>								)							} )						}					</div>				</div>				<div className='tetris-container tetris-prompt'>					<div className='tetris-container-main'>						{							( new Array( 5 ) ).fill( 0 ).map( ( item, j ) => (								<div className='row' key={ j }>									{										( new Array( 5 ) ).fill( 0 ).map( ( item, i ) => {											let index = this.getGridIndex( i, j );											let color = null;											let position = Object.assign( this.promptPosition, {												x: Math.floor( 5 / 2 ),												y: 1,											} );											let promptBlock = this.blocks( position );											promptBlock.pointer = promptBlock.pointer[ position.direction ];											if ( promptBlock && promptBlock.pointer.has( index ) ) color = promptBlock.color;											return (												<Item													key={ index }													color={ color ? color : null }												/>											)										} )									}								</div>							) )						}					</div>				</div>			</div>		)	}}class Item extends Component {	shouldComponentUpdate ( nextProps ) {		return this.props.color !== nextProps.color;	}	render () {		const { color } = this.props;		let className = 'col';		let style = {};		if ( color ) style.background = color;		return (			<div				className={ className }				style={ style }			/>		)	}}export default Tetris;