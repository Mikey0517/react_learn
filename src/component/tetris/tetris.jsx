import React, { Component } from 'react';import '../../assets/css/tetris.css';import { Message, Button } from "element-react";class Tetris extends Component {	constructor ( props ) {		super( props );		this.state = {			block: null,		};		// 界面大小		this.size = {			x: 11,			y: 18		};		// 方块可变形范围		this.randomRange = [ 4, 1, 2, 2, 2, 4, 4 ];		// 历史记录		this.history = [];		// 下落定时		this.time = null;		// 缓存方块		this.cacheBlock = null;		// 下一次提示方块定位		this.promptPosition = null;		// 当前方块定位		this.position = null;		// 得分		this.score = 0;		// 获取方块		this.blocks = ( position ) => {			const { x, y, index, direction } = position;			return [				{					color: '#FF7F24',					pointer: [						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x + 1, y ), [ x + 1, y ] ],							[ this.getGridIndex( x, y - 1 ), [ x, y - 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x, y - 1 ), [ x, y - 1 ] ],							[ this.getGridIndex( x + 1, y ), [ x + 1, y ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x + 1, y ), [ x + 1, y ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x, y - 1 ), [ x, y - 1 ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ]						] ),					][ direction ]				},				{					color: '#1C86EE',					pointer: [						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x + 1, y ), [ x + 1, y ] ],							[ this.getGridIndex( x + 1, y - 1 ), [ x + 1, y - 1 ] ],							[ this.getGridIndex( x, y - 1 ), [ x, y - 1 ] ]						] ),					][ direction ]				},				{					color: '#4EEE94',					pointer: [						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ],							[ this.getGridIndex( x, y - 1 ), [ x, y - 1 ] ],							[ this.getGridIndex( x, y - 2 ), [ x, y - 2 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x + 1, y ), [ x + 1, y ] ],							[ this.getGridIndex( x + 2, y ), [ x + 2, y ] ]						] ),					][ direction ]				},				{					color: '#BFBFBF',					pointer: [						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ],							[ this.getGridIndex( x + 1, y + 1 ), [ x + 1, y + 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x, y - 1 ), [ x, y - 1 ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x - 1, y + 1 ), [ x - 1, y + 1 ] ]						] ),					][ direction ]				},				{					color: '#8B4500',					pointer: [						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x + 1, y ), [ x + 1, y ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ],							[ this.getGridIndex( x - 1, y + 1 ), [ x - 1, y + 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x - 1, y - 1 ), [ x - 1, y - 1 ] ]						] ),					][ direction ]				},				{					color: '#CAFF70',					pointer: [						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ],							[ this.getGridIndex( x, y - 1 ), [ x, y - 1 ] ],							[ this.getGridIndex( x + 1, y - 1 ), [ x + 1, y - 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x + 1, y ), [ x + 1, y ] ],							[ this.getGridIndex( x + 1, y + 1 ), [ x + 1, y + 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x, y - 1 ), [ x, y - 1 ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ],							[ this.getGridIndex( x - 1, y + 1 ), [ x - 1, y + 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x + 1, y ), [ x + 1, y ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x - 1, y - 1 ), [ x - 1, y - 1 ] ]						] )					][ direction ]				},				{					color: '#9A32CD',					pointer: [						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ],							[ this.getGridIndex( x, y - 1 ), [ x, y - 1 ] ],							[ this.getGridIndex( x - 1, y - 1 ), [ x - 1, y - 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x + 1, y ), [ x + 1, y ] ],							[ this.getGridIndex( x + 1, y - 1 ), [ x + 1, y - 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x, y - 1 ), [ x, y - 1 ] ],							[ this.getGridIndex( x, y + 1 ), [ x, y + 1 ] ],							[ this.getGridIndex( x + 1, y + 1 ), [ x + 1, y + 1 ] ]						] ),						new Map( [							[ this.getGridIndex( x, y ), [ x, y ] ],							[ this.getGridIndex( x + 1, y ), [ x + 1, y ] ],							[ this.getGridIndex( x - 1, y ), [ x - 1, y ] ],							[ this.getGridIndex( x - 1, y + 1 ), [ x - 1, y + 1 ] ]						] )					][ direction ]				}			][ index ]		};		// 获取初始方块定位		this.initPosition = () => {			let index = Math.floor( Math.random() * 7 );			let direction = Math.floor( Math.random() * this.randomRange[ index ] );			return {				direction,				index			}		};		// 键盘监听事件响应方法		this.handleKeydown = this.handleKeydown.bind( this );	}	// 初始化	componentWillMount () {		this.run();	}	// 注销	componentWillUnmount () {		if ( this.time ) {			clearInterval( this.time );			this.time = null;		}		document.removeEventListener( 'keydown', this.handleKeydown );	}	// 运行	run () {		const { x } = this.size;		this.clearBlock();		document.addEventListener( 'keydown', this.handleKeydown );		if ( this.promptPosition ) {			this.position = Object.assign( this.promptPosition, {				x: Math.floor( x / 2 ),				y: -2,			} )		} else {			this.position = Object.assign( this.initPosition(), {				x: Math.floor( x / 2 ),				y: -2,			} );		}		this.promptPosition = this.initPosition();		this.time = setInterval( () => {			this.controlBlock( 40 );		}, 1000 )	}	// 启动进程	process ( direction ) {		const history = this.getHistory();		let block = this.blocks( this.position );		switch ( this.check( block.pointer, direction, history ) ) {			case 0:				this.cacheBlock = Object.assign( {}, block );				this.setState( { block } );				break;			case 1:				this.controlBlock( 39 );				break;			case 2:				this.controlBlock( 37 );				break;			case 3:				this.controlBlock( 41 );				break;			case -1:				document.removeEventListener( 'keydown', this.handleKeydown );				clearInterval( this.time );				this.time = null;				this.saveHistory( this.cacheBlock );				this.saveHistory( block );				this.message( 'error', '游戏结束' );				break;			case -2:				document.removeEventListener( 'keydown', this.handleKeydown );				clearInterval( this.time );				this.time = null;				this.saveHistory( this.cacheBlock );				this.run();				break;		}	}	handleKeydown ( e ) {		if ( e.keyCode > 36 && e.keyCode < 41 ) {			this.controlBlock( e.keyCode );		}	}	// 控制方块	controlBlock ( code ) {		const { index, direction } = this.position;		switch ( code ) {			case 37:				this.position.x--;				this.process( 'left' );				break;			case 38:				if ( this.randomRange[ index ] - 1 !== direction ) {					this.position.direction++;				} else {					this.position.direction = 0;				}				this.process( 'up' );				break;			case 39:				this.position.x++;				this.process( 'right' );				break;			case 40:				this.position.y++;				this.process( 'down' );				break;			case 41:				if ( 0 !== direction ) {					this.position.direction--;				} else {					this.position.direction = this.randomRange[ index ] - 1				}				this.process( 'up' );				break;		}	}	// 校验方块	check ( pointer, direction, history ) {		const { x, y } = this.size;		let state = 0;		for ( let dot of pointer.values() ) {			let dotX = dot[ 0 ];			let dotY = dot[ 1 ];			if ( dotY >= y ) {				state = -2;				break;			} else {				let index = y - dotY;				let cross = history.length > 0 && history.length >= index && history[ index - 1 ].has( dotX );				if ( cross && direction === 'down' ) {					for ( let dot of pointer.values() ) {						let dotY = dot[ 1 ];						if ( dotY < 0 ) {							state = -1;							break;						}					}					if ( state !== -1 ) state = -2;					break;				}				if ( direction === 'up' && ( cross || dotX < 0 || dotX >= x ) ) {					state = 3;					break;				} else if ( dotX < 0 || ( cross && direction === 'left' ) ) {					state = 1;					break;				} else if ( dotX >= x || ( cross && direction === 'right' ) ) {					state = 2;					break;				}			}		}		return state;	}	// 提示信息	message ( type, message ) {		Message( {			customClass: '',			message: message,			type: type,			duration: 0		} );	}	// 保存历史	saveHistory ( block ) {		const { y } = this.size;		let history = this.getHistory();		for ( let dot of block.pointer.values() ) {			let dotX = dot[ 0 ];			let dotY = dot[ 1 ];			let indexY = y - dotY;			let historyLength = history.length;			if ( historyLength < indexY ) {				for ( let i = 0; i < indexY - historyLength; i++ ) {					history.push( new Map() );				}			}			let mapY = history[ indexY - 1 ];			mapY.set( dotX, block.color );		}		this.history.push( history );	}	// 清楚方块	clearBlock () {		const { x } = this.size;		let history = this.getHistory();		let reward = 5;		let row = 0;		for ( let i = 0; i < history.length; i++ ) {			if ( history[ i ].size === x ) {				reward += 5;				row++;				history.splice( i, 1 );				i--;			}		}		this.score += row * reward;		this.history.push( history );	}	// 生成key	getGridIndex ( x, y ) {		return `${ x }_${ y }`;	}	// 获取历史	getHistory () {		return this.history.length === 0 ? [] : this.history[ this.history.length - 1 ]	}	// 重置	reset () {		this.history = [];		this.cacheBlock = null;		this.promptPosition = null;		this.position = null;		this.score = 0;		if ( this.time ) {			clearInterval( this.time );			this.time = null;		}		document.removeEventListener( 'keydown', this.handleKeydown );		this.setState( { block: null }, () => {			this.run()		} )	}	render () {		const { block } = this.state;		const { x, y } = this.size;		const history = this.getHistory();		return (			<div className='tetris'>				<div className='tetris-main'>					<div className='table'>						{							( new Array( y ) ).fill( 0 ).map( ( item, j ) => {								let indexY = y - j;								return (									<div className='row' key={ j }>										{											( new Array( x ) ).fill( 0 ).map( ( item, i ) => {												let index = this.getGridIndex( i, j );												let color = null;												if ( history.length > 0 && history.length >= indexY && history[ indexY - 1 ].has( i ) ) color = history[ indexY - 1 ].get( i );												if ( block && block.pointer.has( index ) ) color = block.color;												return (													<Item														key={ index }														color={ color ? color : null }													/>												)											} )										}									</div>								)							} )						}					</div>				</div>				<div className='tetris-right'>					<div className='tetris-prompt'>						<div className='table'>							{								( new Array( 5 ) ).fill( 0 ).map( ( item, j ) => (									<div className='row' key={ j }>										{											( new Array( 5 ) ).fill( 0 ).map( ( item, i ) => {												let index = this.getGridIndex( i, j );												let color = null;												if ( this.promptPosition ) {													let position = Object.assign( this.promptPosition, {														x: Math.floor( 5 / 2 ),														y: 2,													} );													let promptBlock = this.blocks( position );													if ( promptBlock && promptBlock.pointer.has( index ) ) color = promptBlock.color;												}												return (													<Item														key={ index }														color={ color ? color : null }													/>												)											} )										}									</div>								) )							}						</div>					</div>					<div className='tetris-score'>						<div>得分</div>						<hr />						<div>{ this.score }</div>						<hr />						<div onClick={ this.reset.bind( this ) }>重置</div>					</div>				</div>			</div>		)	}}class Item extends Component {	shouldComponentUpdate ( nextProps ) {		return this.props.color !== nextProps.color;	}	render () {		const { color } = this.props;		let className = 'col';		let style = {};		if ( color ) style.background = color;		return (			<div				className={ className }				style={ style }			/>		)	}}export default Tetris;